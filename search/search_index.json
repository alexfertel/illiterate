{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Illiterate \u00b6 Unobstrusive literate programming experience for Python pragmatists illiterate is a Python module that helps you apply some of the literate programming paradigm without requirying a meta-programming language (like noweb ) or any preprocessing step to actually get your code up and running. It works kind of opposite to how literate programming suggests, in the sense that you write code-first and embed documentation into your code. I know, purist literate programmers will hate this but hey, it's a compromise. What is all this (il)literate programming about? \u00b6 If you've never heard about literate programming before, then I suggest you to read at least the Wikipedia entry and then we can continue discussing. It is a fascinating topic, and there are many resources out there. Back already? Ok, so here is illiterate's take on this matter. Ideally, for literate programming to work, you would code in a meta-language mixing prose, code, and macros. This is great if everyone that will ever write code in your project is willing to indulge into literate programming. Sadly, I have found that more often that not, this is not the case. Hence, even though it is awesome, literate programming has some major practical drawbacks that, at this moment, make it impossible for many people to apply it widely, including: Poor support from editors and lack of tooling, which is not just a matter of syntax highlighting. The very feature that makes literate programming extra powerful, i.e., macros, makes it almost impossible for any semantic analysis to work, so forget about intellisense, smart completion or interactive linting. A hard entry curve, since unfortunately people in the 21st century still learns to code the \"old\" way, that is, code-first. Introducing someone into literate programming is hard because it takes some time to grok it and understand the benefits. It's hard to incrementally switch to it. If you already have a somewhat large program writen in the \"traditional\" way, it's very hard to port it to the literate programming paradigm incrementally. All these reasons make it, at least for me, almost impossible to apply pure literate programming in anything more than toy projects. However, I do love the paradigm, and I do think it makes you a better programmer, and makes your code easier to maintain and understand. I wanted a way to introduce as much of literate programming as possible into the traditional programming paradigms, but still being able to use the same tools, introducing literate programming idiosyncrasies incrementally into existing codebases but \"flying under the radar\" as much as possible, so detractors don't complain. Hence, illiterate was born. It is called that way in part because is kind of a twist on the literate programming paradigm, and also because it is supposed to help us illiterates to write more literate code. So what does illiterate proposes? \u00b6 Glad you asked. The idea is to encourage a more literate codebase while introducing as few changes as possible. Specifically, you should not need to use new tools, editor extensions, or preprocessors. Code writen using the illiterate style looks exactly like regular code, but hopefully, a bit better. Everything stems from these key principles: Documentation for a codebase should be writen as prose, and it should be enjoyable to read it top to bottom. It should not be simply a list of modules and methods with few-line descriptions; rather, it should be a cohesive piece of literature that clearly explains the authors intents for any small details and how everything fits into the bigger picture. Documentation should be as close as possible to real code, ideally right next to it, instead of in external markdown files that can easily get out of sync. Furthermore, there should be some automated way to ensure that documentation is up to date, ideally with embedded unit tests that fail if documentation is wrong. Documentation should be written both for users of your code and future developers, and it should be easy for anyone to dive as deep as they want. This means that users only interested in calling your high-level API can easily understand how to use it, while collaborators or anyone wanting to understand how everything works should also be able to follow all the details. To achieve these objectives, illiterate proposes really only one major paradigm shift: Your code is the documentation. That's it. You will simply write all the documentation for your code right inside your code, as comments and as Python docstrings, according that what is more convenient for each case. But keep this in mind, all your code will be published as-is for documentation purposes . Now you are forced to think about your code in terms of: \"well, this will be read by users at some point, so I better make it as publishable as possible\". This means that you can no longer simply put some throw away code in some forsaken _tmp.py file. That file will appear in the documentation, so it better be publishable. How this works? \u00b6 The only thing that illiterate actually does is taking your Python repository and turn it into Markdown files. It will parse all your code, and output nicely formatted Markdown versions of each .py file. It is up to you that what is writen in those .py files is something worth publishing as documentation. To use it, you simply run: python - m illiterate [ src ] [ output ] Where [src] is folder that is the root of your project's code (i.e., the top level folder with an __init__.py inside), and [output] is where you want the markdown files. You can add --copy from:to to copy verbatim some files into the output folder. I do this for copying the Readme.md into an index.md which becomes the homepage. For example, in this project, standing on the root folder (where this Readme is located), you would run the following (\ud83e\udd13 yeah, it is kind if Inception-ish): python -m illiterate illiterate docs --copy Readme.md:index.md This will take all the code in illiterate , convert it to Markdown, and drop it inside the docs folder. It will also copy the Readme.md file into docs/index.md . What you do with those Markdowns is up to you. In this project, I use mkdocs for documentation. If you have mkdocs , then make sure to have your mkdocs.yml correctly configured so that it renders those freshly created markdowns. You can also see the mkdocs.yml in this repostory to get an idea of how that configuration looks, but beware, I'm using some custom themes and other stuff you might or might not want. You can mix illiterate with regular markdown simply by hand-crafting all the documentation you want in pure Markdown and then conveniently designing your mkdocs.yml . Next steps \u00b6 This project is quite small, but it is a self-fulfilling prophecy. The remaining documentation has been written with illiterate . Just keep reading and you'll see for yourself what does this means.","title":"Home"},{"location":"#illiterate","text":"Unobstrusive literate programming experience for Python pragmatists illiterate is a Python module that helps you apply some of the literate programming paradigm without requirying a meta-programming language (like noweb ) or any preprocessing step to actually get your code up and running. It works kind of opposite to how literate programming suggests, in the sense that you write code-first and embed documentation into your code. I know, purist literate programmers will hate this but hey, it's a compromise.","title":"Illiterate"},{"location":"#what-is-all-this-illiterate-programming-about","text":"If you've never heard about literate programming before, then I suggest you to read at least the Wikipedia entry and then we can continue discussing. It is a fascinating topic, and there are many resources out there. Back already? Ok, so here is illiterate's take on this matter. Ideally, for literate programming to work, you would code in a meta-language mixing prose, code, and macros. This is great if everyone that will ever write code in your project is willing to indulge into literate programming. Sadly, I have found that more often that not, this is not the case. Hence, even though it is awesome, literate programming has some major practical drawbacks that, at this moment, make it impossible for many people to apply it widely, including: Poor support from editors and lack of tooling, which is not just a matter of syntax highlighting. The very feature that makes literate programming extra powerful, i.e., macros, makes it almost impossible for any semantic analysis to work, so forget about intellisense, smart completion or interactive linting. A hard entry curve, since unfortunately people in the 21st century still learns to code the \"old\" way, that is, code-first. Introducing someone into literate programming is hard because it takes some time to grok it and understand the benefits. It's hard to incrementally switch to it. If you already have a somewhat large program writen in the \"traditional\" way, it's very hard to port it to the literate programming paradigm incrementally. All these reasons make it, at least for me, almost impossible to apply pure literate programming in anything more than toy projects. However, I do love the paradigm, and I do think it makes you a better programmer, and makes your code easier to maintain and understand. I wanted a way to introduce as much of literate programming as possible into the traditional programming paradigms, but still being able to use the same tools, introducing literate programming idiosyncrasies incrementally into existing codebases but \"flying under the radar\" as much as possible, so detractors don't complain. Hence, illiterate was born. It is called that way in part because is kind of a twist on the literate programming paradigm, and also because it is supposed to help us illiterates to write more literate code.","title":"What is all this (il)literate programming about?"},{"location":"#so-what-does-illiterate-proposes","text":"Glad you asked. The idea is to encourage a more literate codebase while introducing as few changes as possible. Specifically, you should not need to use new tools, editor extensions, or preprocessors. Code writen using the illiterate style looks exactly like regular code, but hopefully, a bit better. Everything stems from these key principles: Documentation for a codebase should be writen as prose, and it should be enjoyable to read it top to bottom. It should not be simply a list of modules and methods with few-line descriptions; rather, it should be a cohesive piece of literature that clearly explains the authors intents for any small details and how everything fits into the bigger picture. Documentation should be as close as possible to real code, ideally right next to it, instead of in external markdown files that can easily get out of sync. Furthermore, there should be some automated way to ensure that documentation is up to date, ideally with embedded unit tests that fail if documentation is wrong. Documentation should be written both for users of your code and future developers, and it should be easy for anyone to dive as deep as they want. This means that users only interested in calling your high-level API can easily understand how to use it, while collaborators or anyone wanting to understand how everything works should also be able to follow all the details. To achieve these objectives, illiterate proposes really only one major paradigm shift: Your code is the documentation. That's it. You will simply write all the documentation for your code right inside your code, as comments and as Python docstrings, according that what is more convenient for each case. But keep this in mind, all your code will be published as-is for documentation purposes . Now you are forced to think about your code in terms of: \"well, this will be read by users at some point, so I better make it as publishable as possible\". This means that you can no longer simply put some throw away code in some forsaken _tmp.py file. That file will appear in the documentation, so it better be publishable.","title":"So what does illiterate proposes?"},{"location":"#how-this-works","text":"The only thing that illiterate actually does is taking your Python repository and turn it into Markdown files. It will parse all your code, and output nicely formatted Markdown versions of each .py file. It is up to you that what is writen in those .py files is something worth publishing as documentation. To use it, you simply run: python - m illiterate [ src ] [ output ] Where [src] is folder that is the root of your project's code (i.e., the top level folder with an __init__.py inside), and [output] is where you want the markdown files. You can add --copy from:to to copy verbatim some files into the output folder. I do this for copying the Readme.md into an index.md which becomes the homepage. For example, in this project, standing on the root folder (where this Readme is located), you would run the following (\ud83e\udd13 yeah, it is kind if Inception-ish): python -m illiterate illiterate docs --copy Readme.md:index.md This will take all the code in illiterate , convert it to Markdown, and drop it inside the docs folder. It will also copy the Readme.md file into docs/index.md . What you do with those Markdowns is up to you. In this project, I use mkdocs for documentation. If you have mkdocs , then make sure to have your mkdocs.yml correctly configured so that it renders those freshly created markdowns. You can also see the mkdocs.yml in this repostory to get an idea of how that configuration looks, but beware, I'm using some custom themes and other stuff you might or might not want. You can mix illiterate with regular markdown simply by hand-crafting all the documentation you want in pure Markdown and then conveniently designing your mkdocs.yml .","title":"How this works?"},{"location":"#next-steps","text":"This project is quite small, but it is a self-fulfilling prophecy. The remaining documentation has been written with illiterate . Just keep reading and you'll see for yourself what does this means.","title":"Next steps"},{"location":"illiterate.__init__/","text":"\"\"\"Illiterate is a Python library for crafting self-documenting code, loosely following the literate programming paradigm. The library itself is coded following illiterate \"best practices\", so by reading this, either in source code or in the rendered documentation, you should be able to understand what we want to achieve. If you don't, then we have done a pretty bad job. \"\"\" The basic idea is that code should be self-explanatory, but not in the sense that it doesn't require comments. Rather, it should be self-explanatory because comments and code together flow naturally and interweave with each other in a manner that is easy to read by people beyond those who wrote it. This means that comments should be writen in prose, with correct grammar, and not in short phrases next to some instructions without any context. It should be pleasing to read. This also means that you are forced to organize your source code in a way that allows the narrative to flow. For example, it will force you to put the most important definitions (clases and methods) at the top, and leave implementation details for the end. I know some will complain, and say \"but why am I forced to organize my code in a specific way!?\". Well, there is no real restriction to organizing code in Python other than for scoping rules, i.e., that any symbol you use is already defined before. Other than that, you either don't care how the code is organized, in which case it is better to have some guidelines, or you do care how your code is organized. In this second case, if the way your code is organized is not already optimized for readibility, then my opinion is that you're organizing it wrong. Plain and simple. With illiterate, you always organize your code in the way that best fits the explanation. And when you are required to import something or define something at some point, then you better have a good excuse for including it there. If you're doing it right, you should have already explained your whys and you should be fairly justified at that point. To get in the right mindset for this paradigm shift, think of your source in the following terms. You are a narrator talking to yourself (the future you), trying to explain how this code works. Instead of the code being the important thing, is the narrative what matters. The code just happens to be inserted into some points of the narrative to actually do what the narrative says. There are many ways to explain an idea, but one of the most succesful from my point of view is by trying to answer the following questions, in order: why, what, and how. Always start with the motivation, why is code necessary, to solve which problem? Then move to the proposed solution, what are you actually gonna do, which are the components of the solution? And then add the implementation details: how is each subtask implemented? There are many advantages to this idea. Two of the most important ones are: Anyone reading this code in the future should be able to understand it, specially because now not only the implementation details are there, but also all the motivation behind choosing some approach rather than another. It will make much easier for yourself to actually develop the project, I promise, because it will force you to think about the problem you want to solve before thinking about the solution. And it will force you to write down explicitely what is that problem, what is the expected solution, which are the main assumptions. Writing as an illiterate \u00b6 Now let's talk about using illiterate. As you have seen so far, these are just regular comments in the code. That's it, nothing has changed. You just need the right mindset. Each comment will be parsed and ultimately rendered as Markdown, so you are free to include any Markdown styling that you want, including lists, bold , code , and even sections (using ## ). At the begining of this file you can see the docstrings. They are rendered exactly the same in the final documentation as regular Markdown, but since they also serve as the internal documentation of this module for IntelliSense purposes, you have to decide how much narrative do you want to be part of the \"core\" documentation. And then you just add the code as always. Illiterate Python files are just regular Python files, so everything should work the same as before. High-level implementation \u00b6 Illiterate is a very simple program. All it does is parse Python files, which are converted to some intermediate representation, and then writes them back in Markdown. However, this \"parsing\" is very simple, because we don't really need to understand the Python code. We just need to separate a file into blocks of Markdown and blocks of Python, and then write that back. To organize this process, we will have classes that represent the different types of content, and then a very simple parser that scans a file top-to-bottom and builds the corresponding block. At this point, however, we only care about the high-level architecture. Starting at root folder, we will process all the .py files in sequence, producing for each one a markdown file that will be saved to the output folder. The outer loop \u00b6 In the output, filenames will match the folder structure that we find, only changing the .py with an .md extension and every \"/\" with a dot. For example src/moduleA/moduleB/file.py will become output/moduleA.moduleB.file.md . We will use pathlib.Path for that purpose. from pathlib import Path Next comes our top level function that processes each file. Notice how we also have docstrings in each function, as usual. Docstrings are for guiding developers when inspecting our code via IntelliSense and such. Hence, they should be fairly self-contained. You will also notice that methods have comments, as usual. However, inline comments do not lend themselves very well to a coherent and flowing narrative. They are better suited to explain very concise ideas. For this reason, illiterate won't render those comments as Markdown. They are an integral part of your code, and will be rendered as code. Hence, you will be forced to refactor your methods so that they are as small as possible. That way, they will have as little comments as possible, ideally none, because the surrounding comments are already enough to make everything as clear as it needs to be. If a method, including comments, is longer than one screen of text, consider refactoring it. One more thing, before I forget, is that we want fancy progress bars . import tqdm And finally, as promised, here comes the function. def process ( src_folder : Path , output_folder : Path ): \"\"\"Processes all the Python source files in `src_folder`, recursively, and writes the corresponding Markdown files to `output_folder`. \"\"\" # Each input file can be found recursively with `.rglob`, # which works pretty much like `ls -lR`. for input_path in tqdm . tqdm ( src_folder . rglob ( \"*.py\" ), unit = \"file\" ): # The output path matches the input path but with the right extension, # using \".\" as separator, and rooted at `output_path` output_path = output_folder / \".\" . join ( input_path . with_suffix ( \".md\" ) . parts ) # And just process that file process_one ( input_path , output_path ) Processing each file \u00b6 Processing a single file is quite straightforward as well. We will be using a Parser class that does all the heavy-lifting. We fed the parser with the input and it will return an object (of type Content ) that knows how to write itself into a file in Markdown. from .core import Parser def process_one ( input_path : Path , output_path : Path ): # We need to create this folder hierarchy if it doesn't exists output_path . parent . mkdir ( exist_ok = True ) # First we parse with input_path . open () as fp : content = Parser ( fp ) . parse () # And then we dump the parsed content with output_path . open ( \"w\" ) as fp : content . dump ( fp ) And that's it. As you can see, being forced to describe our process in this way also forces us to write pretty small methods, and to organize our code in the way that is easier to explain. This might seem daunting at first, but believe me (and thousands of computer scientists and software engineers that have been saying this for decades), every effort that you take now to make your code more readable will be paid in the future when you have to come back. Where to go from here? \u00b6 As you have seen, illiterate makes no assumption about the order in which your files will be read. If you want to force a particular order, that goes into your mkdocs.yml (or wherever your documentation engine says). However, since this is Markdown, you can include links anywhere you want, since only you know how your documentation engine generates links. As an example, you can read more about the Parser class , or you can directy see how the CLI works .","title":"illiterate"},{"location":"illiterate.__init__/#writing-as-an-illiterate","text":"Now let's talk about using illiterate. As you have seen so far, these are just regular comments in the code. That's it, nothing has changed. You just need the right mindset. Each comment will be parsed and ultimately rendered as Markdown, so you are free to include any Markdown styling that you want, including lists, bold , code , and even sections (using ## ). At the begining of this file you can see the docstrings. They are rendered exactly the same in the final documentation as regular Markdown, but since they also serve as the internal documentation of this module for IntelliSense purposes, you have to decide how much narrative do you want to be part of the \"core\" documentation. And then you just add the code as always. Illiterate Python files are just regular Python files, so everything should work the same as before.","title":"Writing as an illiterate"},{"location":"illiterate.__init__/#high-level-implementation","text":"Illiterate is a very simple program. All it does is parse Python files, which are converted to some intermediate representation, and then writes them back in Markdown. However, this \"parsing\" is very simple, because we don't really need to understand the Python code. We just need to separate a file into blocks of Markdown and blocks of Python, and then write that back. To organize this process, we will have classes that represent the different types of content, and then a very simple parser that scans a file top-to-bottom and builds the corresponding block. At this point, however, we only care about the high-level architecture. Starting at root folder, we will process all the .py files in sequence, producing for each one a markdown file that will be saved to the output folder.","title":"High-level implementation"},{"location":"illiterate.__init__/#the-outer-loop","text":"In the output, filenames will match the folder structure that we find, only changing the .py with an .md extension and every \"/\" with a dot. For example src/moduleA/moduleB/file.py will become output/moduleA.moduleB.file.md . We will use pathlib.Path for that purpose. from pathlib import Path Next comes our top level function that processes each file. Notice how we also have docstrings in each function, as usual. Docstrings are for guiding developers when inspecting our code via IntelliSense and such. Hence, they should be fairly self-contained. You will also notice that methods have comments, as usual. However, inline comments do not lend themselves very well to a coherent and flowing narrative. They are better suited to explain very concise ideas. For this reason, illiterate won't render those comments as Markdown. They are an integral part of your code, and will be rendered as code. Hence, you will be forced to refactor your methods so that they are as small as possible. That way, they will have as little comments as possible, ideally none, because the surrounding comments are already enough to make everything as clear as it needs to be. If a method, including comments, is longer than one screen of text, consider refactoring it. One more thing, before I forget, is that we want fancy progress bars . import tqdm And finally, as promised, here comes the function. def process ( src_folder : Path , output_folder : Path ): \"\"\"Processes all the Python source files in `src_folder`, recursively, and writes the corresponding Markdown files to `output_folder`. \"\"\" # Each input file can be found recursively with `.rglob`, # which works pretty much like `ls -lR`. for input_path in tqdm . tqdm ( src_folder . rglob ( \"*.py\" ), unit = \"file\" ): # The output path matches the input path but with the right extension, # using \".\" as separator, and rooted at `output_path` output_path = output_folder / \".\" . join ( input_path . with_suffix ( \".md\" ) . parts ) # And just process that file process_one ( input_path , output_path )","title":"The outer loop"},{"location":"illiterate.__init__/#processing-each-file","text":"Processing a single file is quite straightforward as well. We will be using a Parser class that does all the heavy-lifting. We fed the parser with the input and it will return an object (of type Content ) that knows how to write itself into a file in Markdown. from .core import Parser def process_one ( input_path : Path , output_path : Path ): # We need to create this folder hierarchy if it doesn't exists output_path . parent . mkdir ( exist_ok = True ) # First we parse with input_path . open () as fp : content = Parser ( fp ) . parse () # And then we dump the parsed content with output_path . open ( \"w\" ) as fp : content . dump ( fp ) And that's it. As you can see, being forced to describe our process in this way also forces us to write pretty small methods, and to organize our code in the way that is easier to explain. This might seem daunting at first, but believe me (and thousands of computer scientists and software engineers that have been saying this for decades), every effort that you take now to make your code more readable will be paid in the future when you have to come back.","title":"Processing each file"},{"location":"illiterate.__init__/#where-to-go-from-here","text":"As you have seen, illiterate makes no assumption about the order in which your files will be read. If you want to force a particular order, that goes into your mkdocs.yml (or wherever your documentation engine says). However, since this is Markdown, you can include links anywhere you want, since only you know how your documentation engine generates links. As an example, you can read more about the Parser class , or you can directy see how the CLI works .","title":"Where to go from here?"},{"location":"illiterate.__main__/","text":"This module simply allows calling illiterate as python -m illiterate . We just import the CLI app and setup the right name so that documentation is correct. from .cli import app if __name__ == \"__main__\" : app ( prog_name = \"python -m illiterate\" )","title":"illiterate.main"},{"location":"illiterate.cli/","text":"\"\"\"This module contains the illiterate CLI application. The CLI application is basically a [Typer](https://typer.tiangolo.com) application with a single command, that launches the whole process. \"\"\" The illiterate CLI app is a very simple Typer application with a single command. Typer is a CLI creation tool where you define commands as methods, and it takes advantage of Python type annotations to provide argument parsing and documentation. import typer This is the main function that does all the heavy lifting. from . import process We create a typer application. app = typer . Typer () These are the types for our arguments, and shutil for copying files. from pathlib import Path from typing import List import shutil And here is the command implementation. @app . command () def main ( src_folder : Path , output_folder : Path , copy : List [ str ] = None ): # Not much too see here ;) process ( src_folder , output_folder ) # Copy verbatim all necessary files if copy : for fname in copy : if \":\" in fname : fin , fout = fname . split ( \":\" ) else : fin , fout = fname , Path ( fname ) . name shutil . copy ( fin , output_folder / fout )","title":"illiterate.cli"},{"location":"illiterate.core/","text":"\"\"\"This module contains the classes that represent the types of content inside a Python file and perform the necessary conversions. \"\"\" To represent the different types of content in a single Python file, we will use two classes. These classes will represent, respectively, a block of Python code and a block of Markdown code. The only difference between these two types of content that we care of is how they are printed as Markdown. Other than that, both types of content are simply a list of text lines. There is however one common functionality for both. Depending on how the file is structured, we might end up with spurious empty lines at the begining or end of any block. This might not be a big issue for Markdown, in some cases, but it is definitely a problem for Python code. Hence, we will remove all the empty lines at the begining and the end of each block. The common functionality will go into an abstract class. import abc from typing import Iterable , TextIO , List Content Blocks \u00b6 The only relevant functionality in this class is cleaning up the list of content. We also define abstract method print which inheritors will override to determine how different types of content are printed. class Block ( abc . ABC ): def __init__ ( self , content : List [ str ]): while content : if not content [ 0 ] . strip (): # testing for emptyness content . pop ( 0 ) # from the top down else : break while content : if not content [ - 1 ] . strip (): # testing for emptyness content . pop () # from the bottom up else : break self . content = content @abc . abstractmethod def print ( self , fp : TextIO ): pass Markdown blocks are either formed by lines starting with # (i.e., Python comments) or blank lines. For every line that starts with #_ , we simply remove the first two characters, i.e., the sharp symbol and the starting space. For blank lines, we just output them as-is. class Markdown ( Block ): def print ( self , fp : TextIO ): for line in self . content : if line . startswith ( \"# \" ): fp . write ( line [ 2 :]) else : fp . write ( \" \\n \" ) fp . write ( \" \\n \" ) Python blocks are even easier, since we will print them as-is. The only point to keep in mind is to output a Markdown fenced code block before and after the actual code. class Python ( Block ): def print ( self , fp : TextIO ): if not self . content : return fp . write ( \"```python \\n \" ) for line in self . content : fp . write ( line ) fp . write ( \"``` \\n\\n \" ) Once we have our content types correctly implemented, we will define a container class that stores a sequence of possible Block s. This will make it easier later to dump a bunch of different blocks with a single instruction. class Content : def __init__ ( self , * content : Iterable [ Block ]) -> None : self . content = content def dump ( self , fp : TextIO ): for block in self . content : block . print ( fp ) The Parser \u00b6 Finally, we have come to the core functionality of illiterate, the class that reads Python source code and produces the corresponding blocks. Since we don't really care about the structure of the code, this parser is very simple. Formally, we are dealing with a regular language, since we can determine what type of content we are dealing with based solely on the first character. Intuitively, as long as we are seeing either a # or blank lines, we are seeing Markdown. Once we see a line that doesn't begin with a # , that must be code. The parser is then a very simple automaton with two states. class Parser : def __init__ ( self , input_src : TextIO ) -> None : self . input_src = input_src def parse ( self ): content = [] current = [] state = \"markdown\" for line in self . input_src : if line . startswith ( \"#\" ): if state == \"python\" : if current : content . append ( Python ( current )) current = [] state = \"markdown\" current . append ( line ) else : if state == \"markdown\" : if current : content . append ( Markdown ( current )) current = [] state = \"python\" current . append ( line ) if current : if state == \"markdown\" : content . append ( Markdown ( current )) else : content . append ( Python ( current )) return Content ( * content )","title":"illiterate.core"},{"location":"illiterate.core/#content-blocks","text":"The only relevant functionality in this class is cleaning up the list of content. We also define abstract method print which inheritors will override to determine how different types of content are printed. class Block ( abc . ABC ): def __init__ ( self , content : List [ str ]): while content : if not content [ 0 ] . strip (): # testing for emptyness content . pop ( 0 ) # from the top down else : break while content : if not content [ - 1 ] . strip (): # testing for emptyness content . pop () # from the bottom up else : break self . content = content @abc . abstractmethod def print ( self , fp : TextIO ): pass Markdown blocks are either formed by lines starting with # (i.e., Python comments) or blank lines. For every line that starts with #_ , we simply remove the first two characters, i.e., the sharp symbol and the starting space. For blank lines, we just output them as-is. class Markdown ( Block ): def print ( self , fp : TextIO ): for line in self . content : if line . startswith ( \"# \" ): fp . write ( line [ 2 :]) else : fp . write ( \" \\n \" ) fp . write ( \" \\n \" ) Python blocks are even easier, since we will print them as-is. The only point to keep in mind is to output a Markdown fenced code block before and after the actual code. class Python ( Block ): def print ( self , fp : TextIO ): if not self . content : return fp . write ( \"```python \\n \" ) for line in self . content : fp . write ( line ) fp . write ( \"``` \\n\\n \" ) Once we have our content types correctly implemented, we will define a container class that stores a sequence of possible Block s. This will make it easier later to dump a bunch of different blocks with a single instruction. class Content : def __init__ ( self , * content : Iterable [ Block ]) -> None : self . content = content def dump ( self , fp : TextIO ): for block in self . content : block . print ( fp )","title":"Content Blocks"},{"location":"illiterate.core/#the-parser","text":"Finally, we have come to the core functionality of illiterate, the class that reads Python source code and produces the corresponding blocks. Since we don't really care about the structure of the code, this parser is very simple. Formally, we are dealing with a regular language, since we can determine what type of content we are dealing with based solely on the first character. Intuitively, as long as we are seeing either a # or blank lines, we are seeing Markdown. Once we see a line that doesn't begin with a # , that must be code. The parser is then a very simple automaton with two states. class Parser : def __init__ ( self , input_src : TextIO ) -> None : self . input_src = input_src def parse ( self ): content = [] current = [] state = \"markdown\" for line in self . input_src : if line . startswith ( \"#\" ): if state == \"python\" : if current : content . append ( Python ( current )) current = [] state = \"markdown\" current . append ( line ) else : if state == \"markdown\" : if current : content . append ( Markdown ( current )) current = [] state = \"python\" current . append ( line ) if current : if state == \"markdown\" : content . append ( Markdown ( current )) else : content . append ( Python ( current )) return Content ( * content )","title":"The Parser"}]}